# -*- coding: utf-8 -*-
"""Projeto1_PabloHenrique_IA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MwPNIhfmfmDugOn38bmRQtKUoSj2tQJm
"""

# Instalar bibliotecas necessárias no Google Colab
!pip install scikeras tensorflow matplotlib seaborn scikit-learn
!pip install scikeras[tensorflow]      # gpu compute platform
!pip install scikeras[tensorflow-cpu]  # cpu
!pip uninstall -y scikit-learn
!pip install scikit-learn==1.3.1

# Bibliotecas de manipulação e visualização
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Dataset MNIST
from tensorflow.keras.datasets import mnist

# Pré-processamento e utilitários
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.model_selection import train_test_split

# Keras e Scikit-learn integrados
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.utils import to_categorical
from scikeras.wrappers import KerasClassifier

def adicionar_ruido_gaussiano(imagens, desvio_padrao):
    """
    Adiciona ruído gaussiano às imagens normalizadas (valores entre 0 e 1)
    """
    ruido = np.random.normal(loc=0.0, scale=desvio_padrao, size=imagens.shape)
    imagens_ruidosas = imagens + ruido
    imagens_ruidosas = np.clip(imagens_ruidosas, 0., 1.)  # Mantém no intervalo [0,1]
    return imagens_ruidosas

# Carrega o MNIST
(x_treino, y_treino), (x_teste, y_teste) = mnist.load_data()

# Normaliza os dados
x_treino = x_treino.astype("float32") / 255.0
x_teste = x_teste.astype("float32") / 255.0

# Divide um conjunto de validação do treino
x_treino, x_val, y_treino, y_val = train_test_split(x_treino, y_treino, test_size=0.1, random_state=42)

def criar_modelo(unidades_ocultas=128, ativacao='relu'):
    """
    Cria um modelo MLP simples com uma camada oculta
    """
    modelo = Sequential()
    modelo.add(Flatten(input_shape=(28,28)))
    modelo.add(Dense(unidades_ocultas, activation=ativacao))
    modelo.add(Dense(10, activation='softmax'))
    modelo.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
    return modelo

# Envolve o modelo com o KerasClassifier
modelo_sk = KerasClassifier(model=criar_modelo, verbose=0)

# Define o grid de hiperparâmetros
parametros = {
    "model__unidades_ocultas": [64, 128],
    "model__ativacao": ['relu', 'tanh'],
    "batch_size": [64, 128],
    "epochs": [30]  # Idealmente mais, mas por tempo/recursos deixamos fixo aqui
}

# Aplica ruído leve para o ajuste (desvio 0.1)
x_treino_ruido = adicionar_ruido_gaussiano(x_treino, 0.1)

# Grid Search
grid = GridSearchCV(modelo_sk, parametros, cv=3, scoring='accuracy')
grid.fit(x_treino_ruido, y_treino)

# Exibe os melhores parâmetros
print("Melhores hiperparâmetros encontrados:")
print(grid.best_params_)

# Desvios padrão que serão testados
desvios = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]
acuracias = []

# Avaliação em cada nível de ruído
for desvio in desvios:
    x_teste_ruido = adicionar_ruido_gaussiano(x_teste, desvio)
    y_pred = grid.best_estimator_.predict(x_teste_ruido)
    acuracia = accuracy_score(y_teste, y_pred)
    acuracias.append(acuracia)
    print(f"Desvio {desvio:.1f} - Acurácia: {acuracia:.4f}")

plt.figure(figsize=(16, 6))  # Figura maior para acomodar os dois subplots

# Primeiro subplot (Robustez da RNA)
plt.subplot(1, 2, 1)  # 1 linha, 2 colunas, posição 1
plt.plot(desvios, acuracias, marker='o', linestyle='--', color='blue')
plt.title('Robustez da RNA frente ao Ruído Gaussiano')
plt.xlabel('Desvio Padrão do Ruído')
plt.ylabel('Acurácia')
plt.grid(True)

# Lista de desvios que você utilizou para testar a robustez
desvios = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]

# Loop para avaliar cada desvio
for desvio in desvios:
    print(f"\n====== Avaliação com Ruído Gaussiano σ = {desvio} ======\n")

    # Adiciona ruído gaussiano ao conjunto de teste
    x_teste_ruido = adicionar_ruido_gaussiano(x_teste, desvio)

    # Realiza a predição com o melhor modelo encontrado pelo GridSearch
    y_pred = grid.best_estimator_.predict(x_teste_ruido)

    # Matriz de confusão
    plt.figure(figsize=(8,6))
    sns.heatmap(confusion_matrix(y_teste, y_pred), annot=True, fmt='d', cmap='Blues')
    plt.title(f'Matriz de Confusão (Ruído σ = {desvio})')
    plt.xlabel('Classe Predita')
    plt.ylabel('Classe Verdadeira')
    plt.show()

    # Relatório de classificação
    print("Relatório de Classificação:")
    print(classification_report(y_teste, y_pred))

    # Visualização de 10 imagens classificadas incorretamente
    erros = np.where(y_pred != y_teste)[0]

    if len(erros) >= 10:
        plt.figure(figsize=(12,6))
        for i in range(10):
            idx = erros[i]
            plt.subplot(2, 5, i+1)
            plt.imshow(x_teste_ruido[idx], cmap='gray')
            plt.title(f"Verdade: {y_teste[idx]}\nPredito: {y_pred[idx]}")
            plt.axis('off')
        plt.suptitle(f"Erros de Classificação (Ruído σ = {desvio})")
        plt.tight_layout()
        plt.show()
    else:
        print("Poucos erros para visualizar imagens.")